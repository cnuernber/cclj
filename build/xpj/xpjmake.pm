package xpjmake;
use strict;
use File::Basename;
use File::Spec::Functions;
use XML::LibXML;
use File::Path;
use Cwd qw(realpath getcwd);
my $om;
my $xpj;

sub build_makefile_variable_list_of_lists
{
	my $variable = shift;
	my $varname = shift;
	my $prepend = shift;
	my $retval = "";
	foreach my $list (@$variable) {
		foreach my $item (@$list) {
			$retval = $retval . "$varname += $prepend$item\n";
		}
	}
	return $retval;
}


sub build_makefile_variable_list
{
	my $variable = shift;
	my $varname = shift;
	my $prepend = shift;
	return build_makefile_variable_list_of_lists( [$variable], $varname, $prepend );
}

sub get_makefile_variable_name
{
	my ($targetName, $config, $varname) = @_;
	return $targetName . "_" . $config . "_" . $varname;
}

sub add_project_config
{
	my ($projectConfigs,$targetName,$config) = @_;
	my $existing = $projectConfigs->{$config};
	if ( $existing ) {
		$existing = $existing . " ";
	}
	else {
		$existing = "";
	}
	$existing = $existing . "$targetName" . "_$config";
	$projectConfigs->{$config} = $existing;
}

my $compilation_maps_cflags = {
	"warning-level" => { "0" => "-w", "1" => "", "2" => "", "3" => "", "4" => "-Wall", "5" => "-Wextra" },
	"optimization" => { "disabled" => "-O0", "max-speed" => "-O3", "min-space" => "-Os", full=>"-O3" },
	"generate-debug-information" => { "false" => "", "true" => "-g" },
	"intrinsic-functions" => { "false" => "-fno-builtin", "true"=>"" },
	"buffer-security-check" => { "false"=>"-fno-stack-protector", "true"=>"-fstack-protector" },
	"struct-member-alignment" => { "default"=>"", "1"=>"-fpack-struct=1", "2"=>"-fpack-struct=2"
									   , "4"=>"-fpack-struct=4", "8"=>"-fpack-struct=8", "16"=>"-fpack-struct=16" },
};

my $compilation_maps_cppflags = {
	"enable-exceptions" => { "false"=>"-fno-exceptions", "true"=>"-fexceptions" },
	"enable-rtti" => { "false" => "-fno-rtti", "true"=>"-frtti" },
};

sub safe_lookup_and_append
{
	my ($target, $config, $varname, $file, $propname, $mapvar) = @_;
	my $key = $om->get_target_property( $target, $config, $propname );
	my $map = $mapvar->{$propname};
	die "unable to find mapping for property $propname" if (!$map);
	
	
	my $result = $map->{$key};
	if ( $result ) {
		print $file "$varname += $result\n";
	}
}

sub translate_xpj_compilation_properties_cflags
{
	my ($target, $config, $varname, $file) = @_;
	foreach my $compKey (keys %$compilation_maps_cflags ) {
		safe_lookup_and_append( $target, $config, $varname, $file, $compKey, $compilation_maps_cflags  );
	}
}

sub translate_xpj_compilation_properties_cppflags
{
	my ($target, $config, $varname, $file) = @_;
	foreach my $compKey (keys %$compilation_maps_cppflags ) {
		safe_lookup_and_append( $target, $config, $varname, $file, $compKey, $compilation_maps_cppflags );
	}
}

sub process
{
	($om, $xpj) = @_;
	my $projects = $om->get_projects;
	foreach my $project (@$projects) {
		my $projname = $project->{name};
		my $projfilename = catfile( $project->{project_directory}, $project->{name} ) . ".Makefile";
		open( my $projfile, ">", $projfilename );
		print $projfile "#!/usr/bin/make\n";
		print $projfile "#generated by xpjmake\n\n";
		print $projfile "RM         = rm -rf\n";
		print $projfile "MKDIR      = mkdir -p\n";
		print $projfile "ECHO       = echo\n";
		print $projfile "CCLD       = gcc\n";
		print $projfile "RANLIB     = ranlib\n";
		print $projfile "CC         = gcc\n";
		print $projfile "CXX        = g++\n";

		print $projfile "\n-include Makedefs.$projname\n\n";
		my $targets = $project->{targets};
		my $projectConfigs = {};
		my $projectAll = "";
		my $projectClean = "";
		my $projectIncludes = "";

		foreach my $target (@$targets) {
			my $targetName = $target->{name};
			my $targetMakefileName = "Makefile.$targetName.mk";
			my $targetMakfilePath = catfile( $project->{project_directory}, $targetMakefileName );
			open( my $targetMakefile, ">", $targetMakfilePath );
			my $fileMap = {};
			my $compileGroups = {};
			my $filegroups = $target->{filegroups};
			#condense the filegroups into individual files.  These are configuration independent
			#so we can do this at an upper level.
			foreach my $filegroupName (keys $filegroups) {
				my $filegroup = $filegroups->{$filegroupName};
				my @files = sort( keys( $filegroup->{files} ) );
				foreach my $file (@files) {
					if( !( $fileMap->{$file} ) ) {
						$fileMap->{$file} = 1;
						my $filetype = $om->get_file_type( $file );
						if ( $filetype == $om->{FILE_TYPE_COMPILE} ) {
							my ($dirname, $fname, $ext) = fileparse( $file, qr/\.[^.]*/ );
							#strip the .
							$ext = substr( lc($ext), 1 );
							my $compiler = "CC";
							if ( $ext =~ /cc|cpp|cxx/ ) {
								$compiler = "CXX";
							}
							
							my $compile_varname = $targetName . "_" . $ext . "_files";
							if ( !$compileGroups->{$compile_varname} ) {
								$compileGroups->{$compile_varname} = { compiler=>$compiler, extension=>$ext };
							}
							print $targetMakefile "$compile_varname += $file\n";
						}
					}
				}
			}
			my $configs = $om->get_configuration_names( $target );
			my $cleanStr = "";
			my $allStr = "";
			foreach my $config (@$configs) {
				print $targetMakefile "\n\n";
				my $builddir = catdir( catdir( $project->{build_directory}, $targetName ), $config );
				mkpath( $builddir );
				my $includePathVar = get_makefile_variable_name( $targetName, $config, "hpaths" );
				my $includePath = build_makefile_variable_list( $om->get_path_list( $target, $config, "header" ), $includePathVar );
				my $linkPathVar = get_makefile_variable_name( $targetName, $config, "lpaths" );
				my $linkPath = build_makefile_variable_list( $om->get_path_list( $target, $config, "linker" ), $linkPathVar );
				my $librariesVar = get_makefile_variable_name( $targetName, $config, "libs" );
				my $foundItems = {};
				my $dependsLibs = [];
				my $userLibs = [];
				$om->get_target_input_libraries( $target, $config, $userLibs, $foundItems );
				$om->get_target_depends_libraries( $target, $config, $dependsLibs, $foundItems );
				my $libraries = build_makefile_variable_list( $dependsLibs, $librariesVar, ':' );
				$libraries = $libraries . build_makefile_variable_list( $userLibs, $librariesVar );
				my $artifact_name = $om->get_target_property( $target, $config, "artifact-name" );
				my $configuration_type = $om->get_target_property( $target, $config, "configuration-type" );
				my $out_dir = $om->get_target_out_dir( $target, $config );
				my $cflagsVar = get_makefile_variable_name( $targetName, $config, "cflags" );
				#output the nice-named build system cflags first
				my $cflags = translate_xpj_compilation_properties_cflags( $target, $config
																   , $cflagsVar, $targetMakefile );
				my $cflags = $cflags . build_makefile_variable_list_of_lists( 
					$om->get_target_and_config_nodes_by_type( $target, $config, "cflags" ), $cflagsVar );

				my $cppflagsVar = get_makefile_variable_name( $targetName, $config, "cppflags" );
				my $cppflags = translate_xpj_compilation_properties_cppflags( $target, $config
																	 , $cppflagsVar, $targetMakefile );
				my $cppflags = $cppflags . build_makefile_variable_list_of_lists( 
					$om->get_target_and_config_nodes_by_type( $target, $config, "cppflags" ), $cppflagsVar );
				my $lflagsVar = get_makefile_variable_name( $targetName, $config, "lflags" );
				my $lflags = build_makefile_variable_list_of_lists( 
					$om->get_target_and_config_nodes_by_type( $target, $config, "lflags" ), $lflagsVar );
				my $preprocessorVar = get_makefile_variable_name( $targetName, $config, "preprocessor" );
				my $preprocessor = build_makefile_variable_list_of_lists( 
					$om->get_target_and_config_nodes_by_type( $target, $config, "preprocessor" ), $preprocessorVar );

				my $precompiledHeader = $om->get_target_precompiled_header( $target, $config );
				my $precompiledHeaderVar = ""; 
				
				print $targetMakefile "\n\n#  Configuration $config\n";
				#if there is a precompiled header then that is added as a dependency to every object
				#also it is 
				my $precompiledHeaderCflag = "";
				if ( $precompiledHeader ) {
					$precompiledHeaderVar = get_makefile_variable_name( $targetName, $config, "precompile" );
					my $header = $precompiledHeader->{header};
					my($filename, $directories, $suffix) = fileparse($header);
					print $targetMakefile "$precompiledHeaderVar=$builddir/$filename.gch\n";
					$precompiledHeaderCflag =  "-include $builddir/$filename";
				}
				
					
					
				
				print $targetMakefile $includePath;
				print $targetMakefile $linkPath;
				print $targetMakefile $libraries;
				print $targetMakefile $cflags;
				print $targetMakefile $cppflags;
				print $targetMakefile $lflags;
				print $targetMakefile $preprocessor;
				print $targetMakefile "$cflagsVar += \$(addprefix -D, \$($preprocessorVar))\n" if length($preprocessor);
				print $targetMakefile "$cflagsVar += \$(addprefix -I, \$($includePathVar))\n" if length($includePath);
				print $targetMakefile "$lflagsVar += \$(addprefix -L, \$($linkPathVar))\n" if length($linkPath);
				print $targetMakefile "$lflagsVar += \$(addprefix -l, \$($librariesVar))\n" if length($libraries);

				
				my $final_name = catfile( $out_dir, $artifact_name );

				#setup rules to make all the objects.  These are somewhat independent of the type of the final piece.
				my $allobjs = "";
				my $dependsLibsFullPath = [];
				$foundItems = {};
				$om->get_target_depends_libraries_full_path( $target, $config, $dependsLibsFullPath, $foundItems );
				foreach my $dependLib (@$dependsLibsFullPath) {
					if ( length($allobjs) ) { $allobjs = $allobjs . " "; }
					$allobjs = $allobjs . $dependLib;
				}

				#output step to create the precompiled header
				if ( $precompiledHeader ) {
					print $targetMakefile "\n\n";
					my $header = $precompiledHeader->{header};
					my($filename, $directories, $suffix) = fileparse($header, qr/\.[^.]*/);
					my $dependsFile = "$builddir/$filename.d";
					my $compiler = "CXX";
					my $compileFlags = "\$($cflagsVar)";
					if ( $compiler == "CXX" ) {
						$compileFlags = $compileFlags . " \$($cppflagsVar)";
					}
					
					print $targetMakefile "-include $dependsFile\n";
					print $targetMakefile "\$($precompiledHeaderVar): $header\n";
					print $targetMakefile "\t\$(MKDIR) $builddir\n";
					print $targetMakefile "\tcp $header $builddir/$filename\n";
					print $targetMakefile "\tchmod a+rw $builddir/$filename\n";
					print $targetMakefile "\t\$($compiler) $compileFlags -MMD -MP -MF $dependsFile -x c++-header -c $header -o \$($precompiledHeaderVar)\n";
				}

				foreach my $compile_varname (keys %$compileGroups ) {
					print $targetMakefile "\n";
					my $compileGroup = $compileGroups->{$compile_varname};
					my $compiler = $compileGroup->{compiler};
					my $extension = $compileGroup->{extension};
					my $objs_varname = $compile_varname . "_o";

					my $compileFlags = "\$($cflagsVar)";
					if ( $compiler eq "CXX" ) {
						$compileFlags = $compileFlags . " \$($cppflagsVar)";
					}
					if ( length( $allobjs ) ) { $allobjs = $allobjs . " "; }
					$allobjs = $allobjs . "\$($objs_varname)";
					#create objects variable for this compile group
					print $targetMakefile "$objs_varname = \$(addprefix $builddir/, \$(subst ./, , \$(subst ../, , \$(patsubst %.$extension, %.$extension.o, \$($compile_varname)))))\n";
					#include dependencies for the files in this compile group
					print $targetMakefile "-include \$($objs_varname:%o=%d)\n";
					#output build rule for all files in this compile group
					print $targetMakefile <<END;
\$($objs_varname): $builddir/%.o: \$($precompiledHeaderVar)
	\@\$(ECHO) $targetName: compiling Debug \$(filter %\$*,\$($compile_varname))...
	\@\$(MKDIR) \$(dir \$(\@))
	\$($compiler) $compileFlags $precompiledHeaderCflag -MMD -MP -MF \$(subst .$extension.o,.$extension.d,\$\@) -c \$(filter %\$*,\$($compile_varname)) -o \$\@
END

				}
				print $targetMakefile "\n";
				if ( $configuration_type eq "static-library" ) {
					print $targetMakefile <<END;
$final_name: $allobjs
	\@\$(MKDIR) $out_dir
	\@\$(AR) r $final_name \$^
	\@\$(RANLIB) $final_name
	\@\$(ECHO) building \$\@ complete!
END
				}
				elsif ( $configuration_type eq "dynamic-library" ) {
					print $targetMakefile <<END;
$final_name: $allobjs
	\@\$(MKDIR) $out_dir
	\$(CXX) -shared $allobjs \$($lflagsVar) -lc -o \$\@
	\@\$(ECHO) building \$\@ complete!
END
				}
				elsif ( ( $configuration_type eq "executable" ) 
					|| ( $configuration_type eq "console-executable" ) ) {
					print $targetMakefile <<END;
$final_name: $allobjs
	\@\$(MKDIR) $out_dir
	\$(CCLD) \$^ \$($lflagsVar) -o $final_name
	\@\$(ECHO) building \$\@ complete
END
					
				}
				else {
					die "unrecognized configuration type $configuration_type";
				}

				print $targetMakefile "\n";
				
				my $cleanCommand = $targetName . "_clean_" . $config;
				print $targetMakefile "$cleanCommand:\n\t\$(RM) $builddir/*\n\t\$(RM) $final_name\n";

				if ( length($cleanStr) ) { $cleanStr = $cleanStr . " "; }
				$cleanStr = $cleanStr . $cleanCommand;

				my $buildCommand = $targetName . "_" . $config;
				print $targetMakefile "$buildCommand: $final_name\n";

				if ( length($allStr) ) { $allStr = $allStr . " "; }
				$allStr = $allStr . $buildCommand;

				add_project_config( $projectConfigs, $targetName, $config );
			}
			print $targetMakefile "$targetName" . "_clean: $cleanStr\n";
			print $targetMakefile "$targetName" . "_all: $allStr\n";
			if ( length( $projectAll ) ) { $projectAll = $projectAll . " "; }
			$projectAll = $projectAll . "$targetName" . "_all";

			if ( length( $projectClean ) ) { $projectClean = $projectClean . " "; }
			$projectClean = $projectClean . "$targetName" . "_clean";
				 
			close $targetMakefile;
			$projectIncludes = $projectIncludes . "include $targetMakefileName\n";
		}
		print $projfile "\n\n";
		print $projfile "all: $projectAll\n";
		foreach my $projConfigName (sort(keys %$projectConfigs)) {
			my $projConfigValue = $projectConfigs->{$projConfigName};
			print $projfile "$projConfigName: $projConfigValue\n";
		}
		print $projfile "clean: $projectClean\n\n";
		print $projfile $projectIncludes;
		close $projfile;
	}
}

my $compilation_properties = {
};


return { process=>\&process, extended_compilation_properties=>$compilation_properties };
1;
