package xpjmake;
use strict;
use File::Basename;
use File::Spec::Functions;
use XML::LibXML;
use File::Path;
use Cwd qw(realpath getcwd);
my $om;
my $xpj;

sub build_makefile_variable_list_of_lists
{
	my $variable = shift;
	my $varname = shift;
	my $prepend = shift;
	my $retval = "";
	foreach my $list (@$variable) {
		foreach my $item (@$list) {
			$retval = $retval . "$varname += $prepend$item\n";
		}
	}
	return $retval;
}


sub build_makefile_variable_list
{
	my $variable = shift;
	my $varname = shift;
	my $prepend = shift;
	return build_makefile_variable_list_of_lists( [$variable], $varname, $prepend );
}

sub get_makefile_variable_name
{
	my ($targetName, $config, $varname) = @_;
	return $targetName . "_" . $config . "_" . $varname;
}

sub add_project_config
{
	my ($projectConfigs,$targetName,$config) = @_;
	my $existing = $projectConfigs->{$config};
	if ( $existing ) {
		$existing = $existing . " ";
	}
	else {
		$existing = "";
	}
	$existing = $existing . "$targetName" . "_$config";
	$projectConfigs->{$config} = $existing;
}

sub process
{
	($om, $xpj) = @_;
	my $projects = $om->get_projects;
	foreach my $project (@$projects) {
		my $projname = $project->{name};
		my $projfilename = catfile( $project->{project_directory}, $project->{name} ) . ".Makefile";
		open( my $projfile, ">", $projfilename );
		print $projfile "#!/usr/bin/make\n";
		print $projfile "#generated by xpjmake\n\n";
		print $projfile "RM         = rm -rf\n";
		print $projfile "MKDIR      = mkdir -p\n";
		print $projfile "ECHO       = echo\n";
		print $projfile "CCLD       = g++\n";
		print $projfile "RANLIB     = ranlib\n";
		print $projfile "CC         = gcc\n";
		print $projfile "CXX        = g++\n";

		print $projfile "\n-include Makedefs.$projname\n\n";
		my $targets = $project->{targets};
		my $projectConfigs = {};
		my $projectAll = "";
		my $projectClean = "";
		my $projectIncludes = "";

		foreach my $target (@$targets) {
			my $targetName = $target->{name};
			my $targetMakefileName = "Makefile.$targetName.mk";
			my $targetMakfilePath = catfile( $project->{project_directory}, $targetMakefileName );
			open( my $targetMakefile, ">", $targetMakfilePath );
			my $fileMap = {};
			my $compileGroups = {};
			my $filegroups = $target->{filegroups};
			#condense the filegroups into individual files.  These are configuration independent
			#so we can do this at an upper level.
			foreach my $filegroupName (keys $filegroups) {
				my $filegroup = $filegroups->{$filegroupName};
				my @files = sort( keys( $filegroup->{files} ) );
				foreach my $file (@files) {
					if( !( $fileMap->{$file} ) ) {
						$fileMap->{$file} = 1;
						my $filetype = $om->get_file_type( $file );
						if ( $filetype == $om->{FILE_TYPE_COMPILE} ) {
							my ($dirname, $fname, $ext) = fileparse( $file, qr/\.[^.]*/ );
							#strip the .
							$ext = substr( lc($ext), 1 );
							my $compiler = "CC";
							if ( $ext =~ /cc|cpp|cxx/ ) {
								$compiler = "CXX";
							}
							
							my $compile_varname = $targetName . "_" . $ext . "_files";
							if ( !$compileGroups->{$compile_varname} ) {
								$compileGroups->{$compile_varname} = { compiler=>$compiler, extension=>$ext };
							}
							print $targetMakefile "$compile_varname += $file\n";
						}
					}
				}
			}
			my $configs = $om->get_configuration_names( $target );
			my $cleanStr = "";
			my $allStr = "";
			foreach my $config (@$configs) {
				my $builddir = catdir( catdir( $project->{build_directory}, $targetName ), $config );
				mkpath( $builddir );
				my $includePathVar = get_makefile_variable_name( $targetName, $config, "hpaths" );
				my $includePath = build_makefile_variable_list( $om->get_path_list( $target, $config, "header" ), $includePathVar );
				my $linkPathVar = get_makefile_variable_name( $targetName, $config, "lpaths" );
				my $linkPath = build_makefile_variable_list( $om->get_path_list( $target, $config, "linker" ), $linkPathVar );
				my $librariesVar = get_makefile_variable_name( $targetName, $config, "libs" );
				my $foundItems = {};
				my $dependsLibs = [];
				my $userLibs = [];
				$om->get_target_input_libraries( $target, $config, $userLibs, $foundItems );
				$om->get_target_depends_libraries( $target, $config, $dependsLibs, $foundItems );
				my $libraries = build_makefile_variable_list( $dependsLibs, $librariesVar, ':' );
				$libraries = $libraries . build_makefile_variable_list( $userLibs, $librariesVar );
				my $artifact_name = $om->get_target_property( $target, $config, "artifact-name" );
				my $configuration_type = $om->get_target_property( $target, $config, "configuration-type" );
				my $out_dir = $om->get_target_out_dir( $target, $config );
				my $cflagsVar = get_makefile_variable_name( $targetName, $config, "cflags" );
				my $cflags = build_makefile_variable_list_of_lists( 
					$om->get_target_and_config_nodes_by_type( $target, $config, "cflags" ), $cflagsVar );
				my $lflagsVar = get_makefile_variable_name( $targetName, $config, "lflags" );
				my $lflags = build_makefile_variable_list_of_lists( 
					$om->get_target_and_config_nodes_by_type( $target, $config, "lflags" ), $lflagsVar );
				my $preprocessorVar = get_makefile_variable_name( $targetName, $config, "preprocessor" );
				my $preprocessor = build_makefile_variable_list_of_lists( 
					$om->get_target_and_config_nodes_by_type( $target, $config, "preprocessor" ), $preprocessorVar );
				
				print $targetMakefile "\n\n";
				print $targetMakefile $includePath;
				print $targetMakefile $linkPath;
				print $targetMakefile $libraries;
				print $targetMakefile $cflags;
				print $targetMakefile $lflags;
				print $targetMakefile $preprocessor;
				print $targetMakefile "$cflagsVar += \$(addprefix -D, \$($preprocessorVar))\n" if length($preprocessor);
				print $targetMakefile "$cflagsVar += \$(addprefix -I, \$($includePathVar))\n" if length($includePath);
				print $targetMakefile "$lflagsVar += \$(addprefix -L, \$($linkPathVar))\n" if length($linkPath);
				print $targetMakefile "$lflagsVar += \$(addprefix -l, \$($librariesVar))\n" if length($libraries);

				
				my $final_name = catfile( $out_dir, $artifact_name );

				#setup rules to make all the objects.  These are somewhat independent of the type of the final piece.
				my $allobjs = "";
				my $dependsLibsFullPath = [];
				$foundItems = {};
				$om->get_target_depends_libraries_full_path( $target, $config, $dependsLibsFullPath, $foundItems );
				foreach my $dependLib (@$dependsLibsFullPath) {
					if ( length($allobjs) ) { $allobjs = $allobjs . " "; }
					$allobjs = $allobjs . $dependLib;
				}

				foreach my $compile_varname (keys %$compileGroups ) {
					print $targetMakefile "\n";
					my $compileGroup = $compileGroups->{$compile_varname};
					my $compiler = $compileGroup->{compiler};
					my $extension = $compileGroup->{extension};
					my $objs_varname = $compile_varname . "_o";
					if ( length( $allobjs ) ) { $allobjs = $allobjs . " "; }
					$allobjs = $allobjs . "\$($objs_varname)";
					#create objects variable for this compile group
					print $targetMakefile "$objs_varname = \$(addprefix $builddir/, \$(subst ./, , \$(subst ../, , \$(patsubst %.$extension, %.$extension.o, \$($compile_varname)))))\n";
					#include dependencies for the files in this compile group
					print $targetMakefile "-include \$($objs_varname:%o=%d)\n";
					#output build rule for all files in this compile group
					print $targetMakefile <<END;
\$($objs_varname): $builddir/%.o: 
	\@\$(ECHO) $targetName: compiling Debug \$(filter %\$*,\$($compile_varname))...
	\@\$(MKDIR) \$(dir \$(\@))
	\$($compiler) \$($cflagsVar) -MMD -MP -MF \$(subst .$extension.o,.$extension.d,\$\@) -c \$(filter %\$*,\$($compile_varname)) -o \$\@
END

				}
				print $targetMakefile "\n";
				if ( $configuration_type eq "static-library" ) {
					print $targetMakefile <<END;
$final_name: $allobjs
	\@\$(MKDIR) $out_dir
	\@\$(AR) r $final_name \$^
	\@\$(RANLIB) $final_name
	\@\$(ECHO) building \$\@ complete!
END
				}
				elsif ( $configuration_type eq "dynamic-library" ) {
					print $targetMakefile <<END;
$final_name: $allobjs
	\@\$(MKDIR) $out_dir
	\$(CXX) -shared $allobjs \$($lflagsVar) -lc -o \$\@
	\@\$(ECHO) building \$\@ complete!
END
				}
				elsif ( ( $configuration_type eq "executable" ) 
					|| ( $configuration_type eq "console-executable" ) ) {
					print $targetMakefile <<END;
$final_name: $allobjs
	\@\$(MKDIR) $out_dir
	\$(CCLD) \$^ \$($lflagsVar) -o $final_name
	\@\$(ECHO) building \$\@ complete
END
					
				}
				else {
					die "unrecognized configuration type $configuration_type";
				}

				print $targetMakefile "\n";
				
				my $cleanCommand = $targetName . "_clean_" . $config;
				print $targetMakefile "$cleanCommand:\n\t\$(RM) $builddir/*\n\t\$(RM) $final_name\n";

				if ( length($cleanStr) ) { $cleanStr = $cleanStr . " "; }
				$cleanStr = $cleanStr . $cleanCommand;

				my $buildCommand = $targetName . "_" . $config;
				print $targetMakefile "$buildCommand: $final_name\n";

				if ( length($allStr) ) { $allStr = $allStr . " "; }
				$allStr = $allStr . $buildCommand;

				add_project_config( $projectConfigs, $targetName, $config );
			}
			print $targetMakefile "$targetName" . "_clean: $cleanStr\n";
			print $targetMakefile "$targetName" . "_all: $allStr\n";
			if ( length( $projectAll ) ) { $projectAll = $projectAll . " "; }
			$projectAll = $projectAll . "$targetName" . "_all";

			if ( length( $projectClean ) ) { $projectClean = $projectClean . " "; }
			$projectClean = $projectClean . "$targetName" . "_clean";
				 
			close $targetMakefile;
			$projectIncludes = $projectIncludes . "include $targetMakefileName\n";
		}
		print $projfile "\n\n";
		print $projfile "all: $projectAll\n";
		foreach my $projConfigName (sort(keys %$projectConfigs)) {
			my $projConfigValue = $projectConfigs->{$projConfigName};
			print $projfile "$projConfigName: $projConfigValue\n";
		}
		print $projfile "clean: $projectClean\n\n";
		print $projfile $projectIncludes;
		close $projfile;
	}
}

my $compilation_properties = {
};


return { process=>\&process, extended_compilation_properties=>$compilation_properties };
1;
